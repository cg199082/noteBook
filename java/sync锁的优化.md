# sync锁的优化

## 1. 自旋锁与自适应锁
synchronize锁对性能最大的影响是阻塞的实现，挂起线程和恢复线程都要转入内核态完成，这些操作给系统的并发性能带来很大的压力。虚拟机的开发团队注意到在很多应用上，被锁定的数据的锁定状态只会持续很短的一段时间，为了这一很短时间去挂起和恢复线程并不值得。如果物理机有一个以上的处理器，能让两个以上的线程同时执行，就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。  

自旋锁在jdk1.4.2中就已经引入，只不过默认是关闭的，在jdk1.6中默认开启。自旋锁不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它任然是要占用处理器时间的，因此他适用于锁被占用时间很短的锁情况。如果锁占用的时间很长，自旋锁只会白白消耗处理器时间，而不会有任何有用的工作，反而会带来性能上的浪费。因此自旋等待时间必须有一定的限度，如果超过这个限度任然没有成功获取锁，就使用传统的方式挂起线程。自旋次数默认是10次，可以通过参数-XX:PreBlockSpin来更改。

在jdk1.6引入了自适应的自旋锁，自适应意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有着的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获取得到锁，并且持有锁的线程正在运行，那么虚拟机认为这次自旋也很有可能再次成功，进而将允许自旋等待持续相对更长的时间。如果对于某个锁自旋很少成功获得过，那在以后要获得这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。

