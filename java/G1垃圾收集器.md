# 详解JVM Garbage First(G1) 垃圾收集器

参考文档：https://blog.csdn.net/coderlius/article/details/79272773

garbage first（G1）是垃圾收集领域的最新成果，同时也是hostSpot在jvm上力推的垃圾收集器，并赋予它取代cms的使命，如果使用java8/9，那么有很多可能希望对G1进行评估。

# 概述
G1垃圾收集器是当前垃圾回收技术最前沿的技术成果之一，仔仔JDK7就已经加入jvm的垃圾收集器大家庭中，成为hostSpot重点发展的垃圾回收技术，同优秀的的cms垃圾回收器一样，G1也是关注最小时延的回收器，也同样适合大尺寸堆内存额垃圾回收，官方也推荐使用G1来代替cms。G1最大的特点是弱化了分区，分代的概念，合理利用垃圾收集各个周期的资源，解决其他收集器甚至cms的众多缺陷。

# jvm gc收集器的回顾和比较

![](./source/g1_001.jpg)

从JDK3开始，hostSpot团队一直努力朝着高效收集，减少停顿的方向努力，也贡献了从串行到cms乃至G1在内的一系列优秀的垃圾回收器。上面展示了JDK的垃圾回收大家庭，已经他们相互之间的关系，下面就几种典型的组合进行简单的介绍。

## 串行收集器

![](./source/g1_002.jpg)

串行收集器组合：serial + serial old

> 开启选项： -XX:+SerialGC

串行收集器是最基本的，发展时间最长的，久经考验得的垃圾收集器，也是client模式下默认的收集器配置。  
串行收集器采用单线程stop-the-world的方式进行收集。当内存不足时，串行GC设置停顿标识，待所有线程进入安全点时，应用线程暂停，串行gc开始工作，采用单线程方式回收空间并整理内存。单线程也意味着复杂度更低，占用内存更少，但同时也意味着不能有效地利用多核的优势。事实上，串行收集器特别适合堆内存不高，单核甚至双核的CPU的场景。

## 并行收集器

![](./source/g1_003.jpg)

并行收集器组合：parallel scavenge + parallel old

> 开启选项：-XX:+UseParallelGC 或 -XX:+UseParallelOldGC(可互相激活)

并行收集器是以关注吞吐量为目标的垃圾收集器，也是server模式下的默认收集器配置，对吞吐量的关注主要体现在年轻代的parallel scavenge收集器上。并行收集器和串行收集器的工作模式相似，都是stop-the-world方式，只是暂停时冰箱的进行垃圾回收。年轻代采用复制方法，老年代采用标记整理，在回收的同时还会对内存进行压缩。关注吞吐量主要指年轻代的parallel scavenge收集器，通过两个目标参数-XX:MaxGCPauseMills和-XX:GCTimeRatio,调整新生代空间大小，来减低gc触发的频率。并行收集器适合对吞吐量要求远远高于延迟要求的场景，并且在满足最差延迟的情况下，并行收集器将提供最佳的吞吐量。

## 并发标记清除收集器

![](./source/g1_004.jpg)

并发标记清除收集器组合：parNew + cms + serial old

> 开启选项：-XX:+UseConcMarkSweepGC
并发标记清除cms是以关注延迟为目标，十分优秀的垃圾回收算法。开启后，年轻代使用STW式并行收集，老年代回收采用cms进行垃圾回收，对延迟的关注也主要是体现在老年代上cms上。  
年轻代parNew与并行收集器类似，而老年代cms每个这周期都要经历：初始标记，并发标记，重新标记，并发清理。其中初始标记以STW的方式标记所有根节点对象。并发标记则同