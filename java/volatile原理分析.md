# volatile原理分析

# java内存交互细节
java内存模型中定义了8种操作来完成java的CPU，工作内存，主存之间的操作。
指令|名称|操作的变量所在位置|用途  
--|--|--|--
lock|锁定|主内存|把一个变量识别成一个线程独占的状态
unlock|解锁|主内存|把一个处于锁定状态的变量释放出来，释放后变量才能被其他线程锁定
read|读取|主内存|把一个变量的值从主内存传输到工作内存中，以便随后的load操作
load|载入|工作内存|把read操作从主内存中得到的变量值放入工作内存的变量副本中
use|使用|工作内存|把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行这个操作。  
assign|赋值|工作内存|把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。  
store|存储|工作内存|把一个工作内存的变量传递到主内存中，以便随后的write操作
write|写入|主内存|把store操作从工作内存得到的变量的值放入到主内存的变量中。

如果一个变量从主内存复制到工作内存，那就需要顺序执行read，load；如果中工作内存同步到主内存中就要顺序执行store，write操作。java内存模型中只要求这两对指令必须顺序执行，但其中可以插入其他指令。  
比如同时加载a,b变量到工作内存，一种可能的指令顺序是：read a,read b,load b,load a  

# volatile规则
java内存模型对volatile专门定义了一些特殊的访问规则，当一个变量被定义为volatile后，它具备两种特征：  
1. 线程可见性  
当一条线程修改了这个变量的值，新值对于其他线程是立即可以得知的。在各个线程的工作内存中，volatile变量也可以是存在不一致的情况，但由于每次在使用之前都会先刷新，执行引擎看不到不一致的情况。但是java里的运算并非原子操作，导致volatile在并发下一样是不安全的。  
2. 禁止指令重排序  
普通的变量仅仅会保证在该方法的执行过程中所有的依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。  
假定T表示一个线程，V、W分别表示两个volatile变量，那么在执行read，load，use，assign，store和write操作时需要满足如下条件：  

只有线程T对变量V执行的前一个操作是load时，线程T才能对变量V践行use操作  
只有线程T对变量V的后一个动作是use的时候，线程T才能对变零V执行Load操作

因此可以得出：线程T对变量V的use操作可以认为和线程T对变零V的load，read操作是相关联的，必须连续在一起出现（这条规则要求在工作内存中，每次使用V之前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变零V所做的修改后的值）

只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store操作   
只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变零V执行assign操作  

因此可以得出：线程T对变量V的assign操作可以认为和线程T对变零V的store，write操作是相关联的，必须连续在一起出现（这条规则要求在工作内存中，每次修改V之后都必须立刻同步到主内存中，用于保证其他线程可以看到当前线程对变量V所做的修改后的值）

# java原子性，可见性，有序性
## 原子性
java内存直接保证原子性变量操作的指令包括：read，load，use，assign，store，write；如果要保证更大范围的原子性，java内存模型还提供了lock和unlock操作，尽管虚拟机未把这两个指令开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式的使用这两个操作，这两个操作反映到java代码中就是同步块synchronize关键字，因此synchronize快之间的操作具有原子性。

## 可见性
可见性是指一个线程修改了共享变量的值。其他线程能够立即得知这个修改。java中volatile，synchronize和final可以实现这个样的效果。  
synchronize是通过在执行unlock之前，必须把变量同步到主内存（执行store，write操作）来实现的。  
final的可见性是指：被final修饰的变量一旦在构造器中一旦初始化完毕，并且构造器没有把this的引用传递出去，那在其他线程中就能看到final字段的值。

## 有序性
java有序性可以总结为一句话：如果在本线程中观察，所有的操作都是有序的；如果在其他线程中观察另一个线程，所有的操作都是无序的。  
前半句是指：线程内表现为串行的语义（within-Thread as-if-serial semantics）；后半句是指：指令重排序现象和工作内存和主内存同步延迟现象。

## happen-before原则
happen-before原则是指：先行发生是java内存模型中定义两个操作之间的偏序关系，如果操作A先发生于操作B，其实也就是在说发生操作B之前，操作A产生的影响能被操作B观察到。  
java的happen-before原则和乱序执行是有冲突的，但是happen-before依然存在，主要体现在以下情况下：  
1. 程序次序执行（program order rule）：在一个线程中，按照程序代码顺序，书写在前面的先行发生于书写在后面的。
2. 管程锁定顺序（monitor lock rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。必须是同一个锁，“后面”指的是时间上的先后顺序。
3. volatile变量规则：对一个变量的写操作先行发生于后面对一个变量的读操作
4. 线程启动规则：thread对象的start先行发生于此线程的每一个动作
5. 线程终止规则：线程的所有操作先行发生于对线程的终止检测
6. 线程中断规则：对线程的中断操作，先行发生于被中断线程的代码检测到中断事件的发生
7. 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始
8. 传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，可以得出操作A先行发生于操作C的结论
