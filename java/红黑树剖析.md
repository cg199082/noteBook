# 红黑树剖析

参考文档：[红黑树](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)  
红黑树是一种**自平衡二叉查找树**，可以实现在O(log n)时间内完成查找，插入和删除（n指树中元素的数目）。在计算机科学中应用极其广泛。相对于AVL树，红黑树牺牲了部分平衡性以换取插入删除操作时少量的旋转操作，整体来说性能要由于AVL树。

## 1. 性质
1. 节点是红色或者黑色
2. 根节点是黑色
3. 所有叶子节点都是黑色（叶子节点是NIL节点）
4. 每个红色节点必须有两个黑色节点（从每个叶子节点到根节点的路径上不能有两个连续的红色节点）
5. 从任一节点到其每个叶子节的所有路径都包含相同数目的黑色节点

下图是一个红黑树图：

![](./source/redBlackTree_001.png)

这些约束确保了红黑树的关键特性：从根到叶子的最长路径不多余最短路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入，删除和查找某个值的最坏情况都要求与树的高度成正比，这个在高度上的理论上限允许在最坏情况下都是高效的，而不同于不同的二叉查找树。  
为什么这些性质保证了这些结果，注意到性质4导致了路径中不能有两个毗邻的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因此根据性质5所有最长路径都有相同数目的黑色节点，这就表明了没有路径能多与其他路径的两倍长度。  
在很多数数据结构中，一个几点有可能只有一个子节点，而叶子节点包含数据。用这种范例表示红黑树是可能的。但是这回改变性质并使算法复杂，为此我们使用**NIL叶子**或**空（NULL）叶子**,如上图所示：它不包含数据而只充当数在此结束的标示。这些节点在绘图中经常被省略。导致了这些树好像同上述原则相矛盾，而实际上不是这样。

## 2. 操作
因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。然而在红黑树上进行插入操作和删除操作会导致不再匹配红黑树的性质。恢复红黑树的性质需要少量（O(log n)）的颜色变更（实际上是非常快速的）和不超过三次的树旋转（对于插入操作是两次）。虽然插入和删除很复杂，但操作时间仍然可以保持在O(log n)次。

## 2.1 插入
首先我们以二叉查找树的方式添加节点并标记它为红色。（如果设为黑色，就会导致原有的平衡的红黑树（满足性质5）的平衡性被打破。如果设为红色，只有出现连续两个红色节点时才会出现冲突，因此设为红色导致平衡被打破的几率更小）下面要进行什么操作取决于其他临近节点的颜色。同人类家族树一样，我们使用术语叔父节点来代指一个节点的父节点的兄弟节点。注意：
* 性质1和性质3总是保持着
* 性质4只有增加红色节点，重绘黑色借点为红色节点，做旋转时收到威胁
* 性质5只有增加黑色节点，重绘红色节点为黑色节点，做旋转时受到威胁

在下图的事例中，将要插入的节点标为N,N的父节点标为P,N的祖父节点标为G,N的叔父节点标为U。
使用C语言代码做展示，通过下列函数，可以找到一个节点的叔父节点和祖父节点。
```
 node* grandparent(node *n){
     return n->parent->parent;
 }

 node* uncle(node *n){
     if(n->parent == grandparent(n)->left)
         return grandparent (n)->right;
     else
         return grandparent (n)->left;
 }
```

### 2.1.1 情形1
新节点N位于树的根上，没有父节点。在这种情况下，我们把它重绘为黑色以满足性质2。因为他在每个路径上黑节点的数目都增加1，因此也满足性质5。
```
 void insert_case1(node *n){
     if(n->parent == NULL)
         n->color = BLACK;
     else
         insert_case2 (n);
 }
```

### 2.1.2 情形2
新节点的父节点p是黑色，因此性质4没有失效（新节点是红色）。在这种情况下，树仍然是有效的。性质5也未受到威胁，尽管新节点N有两个黑色叶子节点；但由于新节点N是红色，通过他的每个子节点的路径都有同通过他所取代的黑色的叶子的路径同样数目的黑色节点，所以依然满足这个性质。
```
void insert_case2(node *n){
     if(n->parent->color == BLACK)
         return; /* 树仍旧有效*/
     else
         insert_case3 (n);
 }
```

**注意**：在下列情形中我们假定新节点的父节点都为红色，所以它具有祖父节点；因为如果父节点是根节点，那父节点应当就是黑色。所以新节点总有一个叔父节点，尽管在情形4和5下它可能是叶子节点。

### 2.1.3 情形3

![](./source/redBlackTree_002.png)

如果父节点P和叔父节点U两者都是红色，（此时新插入的节点N作为p的左节点或者是右节点都属于情况3，上图仅显示N作为P左节点的情况）则我们可以将他们两个重绘为黑色并重绘祖父节点G为红色（用来保持性质5）。现在我们的新节点N有了一个黑色的父节点P。因为通过父节点P或叔父节点U的任何路径都必定通过祖父节点G，因此在这些路径上的黑色节点数目没有改变。但是红色的祖父节点可能是根节点，这就违反了性质4。为了解决这个问题，我们在祖父节点G上递归的进行情况1的整个过程。（把G当成是新加入的节点进行各种情况的检测）
```
void insert_case3(node *n){
     if(uncle(n) != NULL && uncle (n)->color == RED) {
         n->parent->color = BLACK;
         uncle (n)->color = BLACK;
         grandparent (n)->color = RED;
         insert_case1(grandparent(n));
     }
     else
         insert_case4 (n);
 }
```
**注意**：在余下的情形中，我们假定父节点P是其父亲节点的左节点。如果它是右节点，情形4和情形5中的左和右应当对调

### 2.1.4 情形4

![](./source/redBlackTree_003.png)

父节点P是红色而叔父节点U是黑色或者缺少，并且新节点N是其父节点的右节点而父节点P又是其父亲节点的左节点。在这种情况下，我们进行一次左旋转调整新节点和其父节点的角色；接着我们按照**情形5**处理以前的父节点P以解决仍然失效的性质4。注意这个调整会导致某些路径通过他们以前不通过的新节点N(比如图中1号叶子节点)或不通过节点P(比如图中3号叶子节点)，但由于这两个节点都是红色，所以性质5仍然有效。
```
 void insert_case4(node *n){
     if(n == n->parent->right && n->parent == grandparent(n)->left) {
         rotate_left(n->parent);
         n = n->left;
     } else if(n == n->parent->left && n->parent == grandparent(n)->right) {
         rotate_right(n->parent);
         n = n->right;
     }
     insert_case5 (n);
 }
```

### 2.1.5 情形5

![](./source/redBlackTree_004.png)

父节点P是红色而叔父节点U是黑色或缺少，新节点N是其父节点的左节点，而父节点P又是其父节点G的左节点。在这种情况下，我们进行针对祖父节点G的一次右旋转；在旋转产生的树中，以前的父节点P现在是新节点N和以前祖父节点G的父节点。我们知道以前的祖父节点G是黑色，否则父节点就不可能是红色。因此我们切换以前的父节点P和祖父节点G的颜色，结果的树满足性质4。性质5也仍然满足，因此通过这三个节点任意一个的所有路径以前都通过祖父节点G,现在他们都通过现在的父节点P。在各自情况下，这都是三个节点中唯一的黑色节点。
```
 void insert_case5(node *n){
     n->parent->color = BLACK;
     grandparent (n)->color = RED;
     if(n == n->parent->left && n->parent == grandparent(n)->left) {
         rotate_right(grandparent(n));
     } else {
         /* Here, n == n->parent->right && n->parent == grandparent (n)->right */
         rotate_left(grandparent(n));
     }
 }
```

**注意**：插入实际上是原地算法，因为上述所有的调用都使用了尾部调用。