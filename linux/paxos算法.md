# paxos算法
paxos算法是莱斯特*兰伯特与1990年提出的一种基于消息传递且具有高度容错特性的一致性算法

## 问题和假设
分布式系统中的节点通信存在两种模型：共享内存(Shared Memory)和消息传递（Messages Passing）。基于消息传递通信模型的分布式系统，不可避免会发生以下错误：进程可能会慢、被杀死或者重启，消息可能会延迟、丢失、重复，在基础的Paxos场景中，先不考录可能出现消息篡改即**拜占庭错误**的情况。Paxos解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致，保证无论发生以上任何异常，都不会破坏决议的一致性。  
一个典型的场景是，在一个分布式数据库系统中，如何各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每个指令上执行一个“一致性算法”以保证每个节点看到的指令一致。一个通用的一致性算法可以应用在很多场景中，是分布式计算的重要问题。因此从20世纪80年代起对于一致性算法的研究就没有停止过。  
为描述Paxos算法，Lamport虚拟了一个叫做Paxos的希腊城邦，这个岛按照议会民主制的政治模式制定法律，但是没有人愿意将自己所有的时间和经理放在这件事上。所以无论是议员、议长还是传递纸条的服务员都不能承诺别人需要时一定会出现，也无法承诺批准决议或者传递消息的时间。但是这里假设没有**拜占庭将军问题**（Byzantine Failture，即虽然有可能一个消息被传递了两次，但是绝对不会出现错误的信息）；只要等待足够的时间，消息就会被传到。另外Paxos岛上的议员是不会反对其他议员的决议的。  
对于分布式系统，议员对应于各个节点，制定的法律对应于系统的状态。各个节点需要进入一个一致的状态。例如在独立的Cache的对称多处理器系统中，各个处理器读内存的某个字节时，必须读到同样的一个值，否则系统就违背了一致性的要求。一致性要求对应于法律条文只能有一个版本。议员和服务员的不确定性对应于节点和消息传递通道的不可靠性。 

## 算法的提出和证明
首先将议员的角色分为：  
* Proposers：提出议案，提案信息包括提案编号和提议的内容Value
* Acceptors：收到提案后可以接受提案，若提案获得多数派（majority）的Acceptors的接受，则称该提案被批准（chosen）
* Learners（允许身兼数职）：只能“学习”被批准的提案。  

划分角色后，下面梳理对应的问题：  
1. 决议Value只有被Proposers提出后才能被批准（未经批准的决议称为草案Proposal）
2. 再一次Paxos算法的执行实例中，只能批准（chosen）一个Value
3. Learners只能获得被批准（chosen）的Value  
另外还要保证Progress，这一点以后再议。
作者通过不断加强上述三个约束（主要是第二个）从而获得了Paxos算法。
批准Value的过程，首先Proposers将Value发送给Acceptors，之后Acceptors对Value进行接受（accept）。为了满足只批准一个Value的约束，要求经多数派（Majority）接受的Value将成为正式的的议程。这是因为无论是按照人数还是权重划分，两组多数派至少有一个公共的Acceptor，如果每个Acceptor只能接受一个Value，约束2就能保证。