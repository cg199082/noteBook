# paxos算法
paxos算法是莱斯特*兰伯特与1990年提出的一种基于消息传递且具有高度容错特性的一致性算法

## 问题和假设
分布式系统中的节点通信存在两种模型：共享内存(Shared Memory)和消息传递（Messages Passing）。基于消息传递通信模型的分布式系统，不可避免会发生以下错误：进程可能会慢、被杀死或者重启，消息可能会延迟、丢失、重复，在基础的Paxos场景中，先不考录可能出现消息篡改即**拜占庭错误**的情况。Paxos解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致，保证无论发生以上任何异常，都不会破坏决议的一致性。  
一个典型的场景是，在一个分布式数据库系统中，如何各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每个指令上执行一个“一致性算法”以保证每个节点看到的指令一致。一个通用的一致性算法可以应用在很多场景中，是分布式计算的重要问题。因此从20世纪80年代起对于一致性算法的研究就没有停止过。  
为描述Paxos算法，Lamport虚拟了一个叫做Paxos的希腊城邦，这个岛按照议会民主制的政治模式制定法律，但是没有人愿意将自己所有的时间和经理放在这件事上。所以无论是议员、议长还是传递纸条的服务员都不能承诺别人需要时一定会出现，也无法承诺批准决议或者传递消息的时间。但是这里假设没有**拜占庭将军问题**（Byzantine Failture，即虽然有可能一个消息被传递了两次，但是绝对不会出现错误的信息）；只要等待足够的时间，消息就会被传到。另外Paxos岛上的议员是不会反对其他议员的决议的。  
对于分布式系统，议员对应于各个节点，制定的法律对应于系统的状态。各个节点需要进入一个一致的状态。例如在独立的Cache的对称多处理器系统中，各个处理器读内存的某个字节时，必须读到同样的一个值，否则系统就违背了一致性的要求。一致性要求对应于法律条文只能有一个版本。议员和服务员的不确定性对应于节点和消息传递通道的不可靠性。 

## 算法的提出和证明
首先将议员的角色分为：  
* Proposers：提出议案，提案信息包括提案编号和提议的内容Value
* Acceptors：收到提案后可以接受提案，若提案获得多数派（majority）的Acceptors的接受，则称该提案被批准（chosen）
* Learners（允许身兼数职）：只能“学习”被批准的提案。  

划分角色后，下面梳理对应的问题：  
1. 决议Value只有被Proposers提出后才能被批准（未经批准的决议称为草案Proposal）
2. 在一次Paxos算法的执行实例中，只能批准（chosen）一个Value
3. Learners只能获得被批准（chosen）的Value  
另外还要保证Progress，这一点以后再议。
作者通过不断加强上述三个约束（主要是第二个）从而获得了Paxos算法。
批准Value的过程，首先Proposers将Value发送给Acceptors，之后Acceptors对Value进行接受（accept）。为了满足只批准一个Value的约束，要求经多数派（Majority）接受的Value将成为正式的的议程。这是因为无论是按照人数还是权重划分，两组多数派至少有一个公共的Acceptor，如果每个Acceptor只能接受一个Value，约束2就能保证。于是产生了一个显而易见的新约束：
```
P1：一个Acceptor必须接受第一次收到的提案
```
注意：P1是不完备的，如果恰好一半的的Acceptor接受的提案具有Value A，另一半的Acceptor接受的提案具有Value B，那么就无法形成多数派，无法批准任何一个Value。  
约束2并不要求只批准一个提案，按时可能存在多个提案。只要提案Value是一样的，批准多个提案不违背约束2.于是可以产生约束P2：  
```
P2：一旦一个具有Value V的提案被批准，那么之后批准的提案必须具有Value V
```
注：通过某种方式可以为每个提案分配一个编号，在提案之间建立一个全序关系，所谓“之后”都是指所有编号更大的提案。  
如果P1和P2都能够保证，那么约束2就能够保证。批准一个Value意味着多个Acceptor接受了该Value。因此对P2进行加强：  
```
P2a：一旦一个具有Value V的提案被批准（chosen），那么之后任何Acceptor再次接受（accept）的提案必须具有Value V
```
由于通信是异步的，P2a和P1会发生冲突。如果一个Value被批准后，一个Proposer和一个Acceptor从休眠中苏醒，前者提出来一个具有新的Value的提案。根据P1后者应当接受，根据P2a，则不应当接受，这种场景下P2a和P1就有了矛盾。于是需要换个思路，转而对Proposer的行为进行约束：
```
P2b：一旦一个具有Value V的提案被批准（chosen），那么以后任何Proposer提出的提案必须具有Value V
```
由于Acceptor能接受的提案都必须由Proposer提出，所以P2b蕴含了P2a，是一个更强的约束。但是根据P2b难以提出实现手段。因此需要进一步加强P2b。  
假设一个编号为M的Value V已经获得批准（chosen），来看看什么情况下对任何编号为n(n>m)的提案都含有Value V。因为m已经获得批准（chosen），显然存在一个Acceptor的多数派C，他们都是接受（accept）了Value V。考录到任何多数派都和C具有至少一个公共成员，可以找到蕴含P2b的约束P2c：
```
P2c：如果一个编号为n的提案具有Value V，那么存在一个多数派，要么他们中的所有人都没有接受（accept）编号小于n的任何提案，要么他们已经接受（accept）的所有编号小于n的提案中编号最大的那个提案具有Value V
```
可以用数据归纳法证明P2c包含P2b：  
假设具有Value V的提案m获得批准，当n=m+1时，采用反证法，假设提案n不具有Value V，而是具有Value W，根据P2c，则存在一个多数派S1，要么他们中没有人接受过编号小于N的任何提案，要么他们已经接受的所有编号小于N的提案中编号最大的那个提案是Value W。由于S1和通过提案M是的多数派C之间至少有一个公共的Acceptor，所以以上两个条件都不成立，导出矛盾从而推翻假设，证明了提案N必须具Value V；  
若（m+1）...(n-1)所有的提案都具有Value V，采用反证法，假如新提案不具有Value V，而是具有Value W，根据P2c，则存在一个多数派S2，要么他们没有接受过m...(n-1)中的任何提案，要么他们已经接受的所有编号小于N的提案中编号最大的那个提案是Value W。由于S2和通过m的多数派之间至少有一个公共的Acceptor，所以至少有一个Accetpor曾经接受了M，从而也可以推出S2中已接受的所有编号小于N的提案中编号最大的那个提案的编号的范围在m...(n-1)之间，而根据初始假设m...(n-1)之间的所有提案都具有Value V，所以S2中已接受的所有编号小于n的天中编号最大的那个提案肯定具有Value V，导出矛盾从而推翻新提案N不具有Value V的假设。根据数据归纳法，我们证明如果满足P2c，则P2b一定满足。  
P2c是可以通过消息传递模型实现的。另外，引入了P2c后，也解决了P1不完备的问题。

## 算法内容
要满足P2c的约束，propose提出了一个提案前，首先要和足以形成多数派的Acceptor进行通信，获得他们进行的最近一次接受（accept）的提案（prepare过程），之后根据回收的信息决定这次提案的Value，形成提案开始投票。当获得多数的Acceptors接受（accept）后，提案获得批准（chosen），由Acceptor将这个消息告知Learner。这个简略的过程进过进一步细化就形成了Paxos算法。  
在一个Paxos实例中，每一个提案需要不同的编号，且编号存在全序关系。可以用多种方法实现这一点，例如将序数和Proposer的名字拼接起来。如何做到这一点不在Paxos算法讨论的范围内。  
如果一个没有chosen过任何Proposer提案的Acceptor在prepare过程中回答了一个Proposer针对提案n的问题，但是开始对N进行投票前，有接受（accept）了编号小于N的另一个提案（n-1）,如果n-1和n具有不同的Value，这个投票就会违背P2c。因此在prepare过程中，Acceptor进行的回答同时也应当包含承诺：不会再接受（accept）编号小于N的提案。这是对P1的加强：
```
P1a：当且仅当Acceptor没有回应过任何一个编号小于N的Prepare请求是，Acceptor接受（accept）编号为N的提案
```
现在已经可以提出完成的算法了。

### 决议的提出与批准
通过一个决议分成两个阶段：  
1. prepare阶段：
    1. Proposer选择一个提案编号N并将Prepare请求发送给Acceptor中的一个多数派
    2. Acceptor收到Prepare消息后，如果提案编号大于它已经回复的所有Prepare消息（回复消息表示接受accept），则Acceptor将自己上次接受的提案回复给Proposer，并承诺不再回复小于N的提案
2. 批准阶段：
    1. 当一个Proposer收到多个Acceptor对prepare的回复后，就进入批准阶段。它要回复Prepare请求的Acceptors发送accept请求，包括编号N和根据P2c决定的Value（如果P2c没有已经批准的Value那么它可以自由决定Value）
    2. 在不违背自己向其他Proposer的承诺的前提下，Acceptor收到accept请求后批准这个请求

这个过程在任何时候中断都可以保证正确性。例如如果一个Proposer已经发现有其他的Proposers提出了编号更高的提案，则有必要中断这个过程。因此为了优化，在上述Prepare过程中，如果一个Acceptor发现存在一个更高编号的提案，则需要需要通知Proposer，提醒其中断这次提案。

### 实例
用实例来更清楚的描述上述过程：  
有A1，A2,A3,A4,A5 五位议员，就税率问题进行决议。议员A1决定将税率定位10%，因此他向所有人发出一个如下草案。
```
现在的税率是什么？如果没有决定，则建议将其定为10%。时间：本届会议第3年3月15日；提案者：A1
```
在最简单的情况下，没有人与其竞争；信息能及时顺利的传递到其他议员处。于是A2-A5回应：
```
我们已经收到你的提案，等待最终批准。
```
而A1在收到两份回复后就发布最终决议：
```
税率一定为10%，新的提案不得再讨论本问题
```
这实际上退化为了二阶提交协议。  
现在我们假设在A1提出提案的同时，A5决定将税率定位20%
```
现在的税率是什么？如果没有决定，则建议将其定为20%。时间：本届议会第3年3月15日；提案者：A5
```
草案要通过侍从送到其他议员的案头，A1的草案将有4为侍从送到A2-A5哪里。现在负责A2和A3的侍从将草案顺利送达，负责A4和A5的侍从则不上班，A5的草案则顺利送至A3和A4的手中。现在A1，A2,A3收到A1的草案；A3，A4,A5收到A5的草案。按照协议A1,A2,A4,A5将接受他们收到的提议，侍从将拿着
```
我收到你的提议，等待批复
```
的回复回到提案者哪里。而A3的行为将决定批准哪一个。

#### 情况一
假设A1的提案先送到A3处，而A5的侍从决定先放假一段时间。于是A3解释了A1并派出了侍从。A1等到了两位侍从，加上他自己构成一个多数派，于是税率10%将成为决议。A1派出侍从将决议送到所有议员处：
```
税率一定为10%，新的提案不得在讨论本问题
```
A3在很久以后收到来自A5的提案。由于税率已经讨论完毕，他决定不再理会。于是他抱怨一句：
```
税率已经在之前定为10%，你不要再来烦我！
```
这个回复可能对A5有帮助，因为A5可能因为某种原因很久无法与外界联系了。也可能对A5没有任何作用，因为A5已经从A1处获得了刚才的决议。

#### 情况二
依然假设A1提案先送到A3处，但这次A5的侍从不是放假了，只是中途耽误了一会。这次A3依然会“接受”回复A1，但是决议成型之前他又收到A5的提议，这种协议有两种处理方式：  
1. 如果A5的提案更早，按照传统应该提案较早的提案者主持投票。现在看来两份提案的时间一样。但是A5是个惹不起的大人物。于是A3回复：
```
我已经收到你的提案，等待最终审批，但是你之前有人提出将税率定为10%。请明察。
```
于是A1和A5都收到足够的回复。这时关于税率的问题就有两个提案在同时进行。但是A5知道之前有人提出税率为10%。于是A1和A5都向全体议员广播：
```
税率已定为10%,新的提案不得在讨论本问题。
```
一致性得到保证。
2. A5是一个无足轻重的小任务，这时A3不再理会他，A1不久后就会广播税率定位10%。

#### 情况三
在这个情况下，我们将看到，根据天的时间和提案者权势决定是否应答是有意义的。在这里，时间和提案者的权势就构成了给提案者编号的依据。这样的编号符合“任何两个提案之间构成偏序”的要求。  
A1和A5同时提出上述提案，这时A1可以正常联系A2和A3；A5也可以正常联系这两个人。这次A2先收到A1的提案；A3先收到A5的提案，A5的权势更大。在这种情况下，已经回答A1的A2发现比A1更有权势的A5提出了税率20%的新提案，于是回复A5说：  
```
我已经收到您的提案，等待最终批准。
```
而回复了A5的A3发现新的提案者A1是个小人物，不予理会。A1没有达到多数，A5达到了，于是A5将主持投票，决议内容是A5提出的税率20%。如果A3决定平等的对待每一位议员，对A1做出“你之前有人提出将税率定为20%”的回复，则将造成混乱。这种情况下A1和A5将试图主持投票，但是两份提案的内容不同。这种情况下，A3若对A1进行回复只能说：
```  
有更大的人物关注此事，请等待他作出决定。
```
另外，在这种情况下A4与外界失去联系。等到他恢复联系，并需要得知税率情况是，他（在最简单的协议中）将提出一个提案：  
```
现在的税率是什么？如果没有决定，则建议将其定为15%。时间：本届议会第3年4月1日；提案者：A4
```
这时，（在最简单的协议中）其他议员将会回复：  
```
税率已在之前投票中定为20%，你不要再来烦我！
```

### 决议的发布
一个显而易见的方法是当Acceptor批准一个Value时，将这个消息送给所有的Learners。但是这个方法将导致消息量过大。  
由于假设没有Byzantine Failures，Learners可以通过别的Learners获取已经通过的协议。因此Acceptors只需要将批准的消息发送给指定的某一个Learner，其他Learners向他询问已经通过的协议。这个方法降低了消息量，但是指定的Learner失效将引起系统失效。  
因此Acceptors需要将Accept消息发送给Learners的一个子集，然后由这些Learners去通知其他所有的Learners。  
但是由于消息传递的不确定性，可能会没有任何Learners获得了决议批准的消息。当Learners需要了解决议通过情况时，可以让一个Proposer重新进行一次提案。注意一个Learner可能兼任Proposer。

### Progress的保证
根据上述过程当一个Proposer发现存在编号更大的提案时将终止提案。这意味着提出一个编号更大的提案会终止之前的提案过程。如果两个Proposer在这种情况下都转为提出一个编号更大的提案，就可能陷入活锁，违背了Progress的要求。一般活锁可以通过**随机睡眠-重试**的方式解决。这种情况下的解决方案是选举出一个Leader，仅允许Leader提出提案。但是由于消息传播的不确定性，可能有多个Proposers自认为自己已经成为Leader。Lamport在[The Part-Time Parlianment](http://lamport.azurewebsites.net/pubs/lamport-paxos.pdf)一文中描述并解决了这个问题。  


## Multi-Paxos
Paxos的典型部署需要一组连续的被接受值Value，作为应用到一个分布式状态机的一组命令。如果每个命令都通过一个Basic Paxos算法实例来达到一致，会产生大量开销。  
如果Leader是相对稳定不变的，第一阶段就变得不必要。这样，系统可以在接下来的Paxos算法实例中，跳过第一阶段，直接使用同样的Leader。  
为了实现这一目的，在同一个Leader执行每轮Paxos算法时，提案编号I每次递增一个值，并与每个值一起发送。Multi-Paxos在没有故障发生时，将消息延迟（从Propose阶段到Learn阶段）从4次延迟降低到2次延迟。  

### Multi-Paxos中消息流的图形表示
#### Multi-Paxos没有失败的情况
在下面的图中，只显示了基本的Paxos协议的一个实例和一个初始化Leader（Proposer）。注意，Multi-Paxos使用几个Basic Paxos的实例。  
```
Client   Proposer      Acceptor     Learner
   |         |          |  |  |       |  | --- First Request ---
   X-------->|          |  |  |       |  |  Request
   |         X--------->|->|->|       |  |  Prepare(N)
   |         |<---------X--X--X       |  |  Promise(N,I,{Va,Vb,Vc})
   |         X--------->|->|->|       |  |  Accept!(N,I,V)
   |         |<---------X--X--X------>|->|  Accepted(N,I,V)
   |<---------------------------------X--X  Response
   |         |          |  |  |       |  |
```
式中V=(Va,Vb,Vc)中最新的一个。  

#### 跳过阶段1时的Multi-Paxos
在这种情况下，Basic Paxos的后续实例（由I+1表示）使用相同的Leader，因此，包含在Prepare和Promise的阶段1（Basic Paxos协议的这些后续实例）将被跳过。注意，这里要求Leader应该是稳定的，即他不应该崩溃或者改变。  
```
Client   Proposer       Acceptor     Learner
   |         |          |  |  |       |  |  --- Following Requests ---
   X-------->|          |  |  |       |  |  Request
   |         X--------->|->|->|       |  |  Accept!(N,I+1,W)
   |         |<---------X--X--X------>|->|  Accepted(N,I+1,W)
   |<---------------------------------X--X  Response
   |         |          |  |  |       |  |
```


## Fast-Paxos
Fast-Paxos将Basic-Paxos进行了推广，以减少端到端的延迟。在Basic-Paxos中，由客户端发起请求开始，到Lean阶段结束的消息延迟是3个消息延迟。而Fast-Paxos允许2个消息延迟，但要求：  
1. 系统由3f+1个Acceptors组成，以容忍最多f个错误（而不是Basic-Paxos的2f+1）
2. 客户端需要直接将请求发送到多个目标  
直观上，如果Leader没有提议任何Value，那么客户端可以直接发送Accept消息到接收方，Acceptor会像Basic-Paxos一样运行，向Leader和每个Learner发送Accepted的消息，从而实现从客户端到Learner的两消息延迟。  
如果Leader检测到冲突，他通过发起新一轮投票，并发送Accept消息来解决从冲突，通常是一个Accepted消息。这种有协调者参与的冲突恢复机制需要4个从客户端到Learner的消息延迟。  
如果Leader提前指定了一种冲突恢复机制，就可以实现另一种优化，他允许Acceptors自己执行冲突恢复。因此，无协调的冲突恢复可能实现三个消息延迟（如果所有的的Learner都是接收者，那么就只有两个消息延迟）  

### 消息流：Fast-Paxos，无冲突
```
Client    Leader         Acceptor      Learner
   |         |          |  |  |  |       |  |
   |         X--------->|->|->|->|       |  |  Any(N,I,Recovery)
   |         |          |  |  |  |       |  |
   X------------------->|->|->|->|       |  |  Accept!(N,I,W)
   |         |<---------X--X--X--X------>|->|  Accepted(N,I,W)
   |<------------------------------------X--X  Response(W)
   |         |          |  |  |  |       |  |
```

### 消息流：Fast-Paxos，冲突的建议
#### 有协调参与者的冲突恢复。
注意：协议没有指定如何处理被丢弃的客户端请求。
```
Client   Leader      Acceptor     Learner
 |  |      |        |  |  |  |      |  |
 |  |      |        |  |  |  |      |  |
 |  |      |        |  |  |  |      |  |  !! Concurrent conflicting proposals
 |  |      |        |  |  |  |      |  |  !!   received in different order
 |  |      |        |  |  |  |      |  |  !!   by the Acceptors
 |  X--------------?|-?|-?|-?|      |  |  Accept!(N,I,V)
 X-----------------?|-?|-?|-?|      |  |  Accept!(N,I,W)
 |  |      |        |  |  |  |      |  |
 |  |      |        |  |  |  |      |  |  !! Acceptors disagree on value
 |  |      |<-------X--X->|->|----->|->|  Accepted(N,I,V)
 |  |      |<-------|<-|<-X--X----->|->|  Accepted(N,I,W)
 |  |      |        |  |  |  |      |  |
 |  |      |        |  |  |  |      |  |  !! Detect collision & recover
 |  |      X------->|->|->|->|      |  |  Accept!(N+1,I,W)
 |  |      |<-------X--X--X--X----->|->|  Accepted(N+1,I,W)
 |<---------------------------------X--X  Response(W)
 |  |      |        |  |  |  |      |  |
```

#### 无协调者参与的冲突恢复
```
Client   Leader      Acceptor     Learner
 |  |      |        |  |  |  |      |  |
 |  |      X------->|->|->|->|      |  |  Any(N,I,Recovery)
 |  |      |        |  |  |  |      |  |
 |  |      |        |  |  |  |      |  |  !! Concurrent conflicting proposals
 |  |      |        |  |  |  |      |  |  !!   received in different order
 |  |      |        |  |  |  |      |  |  !!   by the Acceptors
 |  X--------------?|-?|-?|-?|      |  |  Accept!(N,I,V)
 X-----------------?|-?|-?|-?|      |  |  Accept!(N,I,W)
 |  |      |        |  |  |  |      |  |
 |  |      |        |  |  |  |      |  |  !! Acceptors disagree on value
 |  |      |<-------X--X->|->|----->|->|  Accepted(N,I,V)
 |  |      |<-------|<-|<-X--X----->|->|  Accepted(N,I,W)
 |  |      |        |  |  |  |      |  |
 |  |      |        |  |  |  |      |  |  !! Detect collision & recover
 |  |      |<-------X--X--X--X----->|->|  Accepted(N+1,I,W)
 |<---------------------------------X--X  Response(W)
 |  |      |        |  |  |  |      |  |
```

### 消息流：无协调者的冲突恢复，角色崩溃的Fast-Paxos
(合并Acceptor/Learner)
```
Client         Servers
 |  |         |  |  |  |
 |  |         X->|->|->|  Any(N,I,Recovery)
 |  |         |  |  |  |
 |  |         |  |  |  |  !! Concurrent conflicting proposals
 |  |         |  |  |  |  !!   received in different order
 |  |         |  |  |  |  !!   by the Servers
 |  X--------?|-?|-?|-?|  Accept!(N,I,V)
 X-----------?|-?|-?|-?|  Accept!(N,I,W)
 |  |         |  |  |  |
 |  |         |  |  |  |  !! Servers disagree on value
 |  |         X<>X->|->|  Accepted(N,I,V)
 |  |         |<-|<-X<>X  Accepted(N,I,W)
 |  |         |  |  |  |
 |  |         |  |  |  |  !! Detect collision & recover
 |  |         X<>X<>X<>X  Accepted(N+1,I,W)
 |<-----------X--X--X--X  Response(W)
 |  |         |  |  |  |
```

参考文档：
https://zh.wikipedia.org/wiki/Paxos%E7%AE%97%E6%B3%95